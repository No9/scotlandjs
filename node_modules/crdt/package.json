{
  "author": {
    "name": "Dominic",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "name": "crdt",
  "description": "Commutative Replicated Data Types for easy distributed/collaborative apps",
  "version": "3.5.1",
  "homepage": "http://github.com/dominictarr/crdt",
  "repository": {
    "url": "git://github.com/dominictarr/crdt.git"
  },
  "scripts": {
    "test": "asynct test/*.js"
  },
  "dependencies": {
    "between": "~0.1",
    "scuttlebutt": "~5.5"
  },
  "devDependencies": {
    "it-is": "~1.0.1",
    "event-stream": "~3.0",
    "asynct": "~1.1",
    "assertions": "~2.3",
    "kv": "~0.5",
    "mux-demux": "~3.2"
  },
  "optionalDependencies": {},
  "readme": "#CRDT - Commutative Replicated Data Types\n\na CRDT is a data type designed so that operations on it commute - give the same result\nindepent of the order in which they are applied.\n\nCRDTs give you eventual consistency for free. it is not necessary to track concurrent changes\nand use complicated merge algorithms. this module is useful for collaborative/distributed/peer2peer (same things)\napplications.\n\nFurther Reading: [A comprehensive study of\nConvergent and Commutative Replicated Data Types\n](http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf)\n\n\n## replicating documents\n\ncreate two documents,\n\n``` js\nvar Doc = require('crdt').Doc\nvar A = new Doc()\nvar B = new Doc()\n```\n\nthen pipe them together\n\n``` js\nvar as\n(as = A.createStream())\n  .pipe(B.createStream())\n  .pipe(as)\n```\n\nWe just replicated two documents with in the same process...\nthis is the idea, but of course, we want to do it on different machines...\n\nnotice the pattern is basically the same...\n\nthe client side ...\n\n``` js\nvar net = require('net')\nvar es  = require('es')\nvar Doc = require('crdt').Doc\n\nvar A = new Doc()\n\nvar stream\n(stream = net.connect())\n  .pipe(A.createStream())\n  .pipe(stream)\n```\n\nand the server ...\n\n``` js\nvar net = require('net')\nvar es  = require('es')\nvar Doc = require('crdt').Doc\n\nvar A = new Doc()\n\nnet.createServer(function (stream) {\n  stream\n    .pipe(A.createStream())\n    .pipe(stream)\n})\n```\n\n## Doc\n\n### Doc#add(obj = {id: ID, ...})\n\nAdd a `Row` to the document initialized to `obj`.\nIf `obj` doesn't have a unique `id` property, a random key will be created.\n\nReturn the `Row` object.\n\n### Doc#rm(id)\n\nRemove a `Row` from the document by `id`\nAlso removes from all sets as well.\n\n\n### Doc#createSet (key, value)\n\nCreate a `Set` a set is a collection of rows defined by a particular\nvalue on a particular property.\n\n``` js\n\nvar cheeses = doc.createSet('type', 'cheese')\n\n```\n\n`key` and `value` must both be strings.\n\n### Doc#createSet (filter)\n\nYou can also create a `Set` using a filter function.\n\n```js\nvar cheeses = doc.createSet(function (state) {\n    return state.type === 'cheese'\n})\n```\n\nA filter function should just be a more expressive filter and\nshouldn't be a stateful function\n\n### Doc#createSeq (key, value)\n\nsame as `Doc#createSet` except that seqs have a significant order.\n\nsequences can also be created with a filter using `Doc#createSeq(filter)`\n\n### Doc#createStream (opts)\n\ncreate a stream that is used to connect to another Doc instance.\n\n### event: doc.emit('create', row)\n\nEmitted when a new `Row` is created\n\n### event: doc.emit('row_update', row)\n\nEmitted when a new `Row` is updated\n\n## Row\n\nan object with in a crdt `Doc`\n\n### Row#set(key, value)\n\nset `key` to `value`. if `Row#set(obj)` is called instead\nall the keys in obj will update atomically.\n\nThis causes a 'change' event to be emitted, and an update message\nto be sent down the stream. (note, if the stream in not yet connected,\nthat is okay, current state of the document is replicated as soon as the\nstreams are connected.)\n\n### Row#get(key)\n\nget the current value for a key.\n\n### Row#toJSON()\n\nreturn a raw object ready for serialization.\nthis is not a JSON string yet, misleading name,\nbut that is the correct JSON.stringify api.\n\n### event: Row.emit('change', changed)\n\nEmitted when a row is changed. this may be the result of a local or a\nremote update.\n\nchanged is the a hash of the fields that have changed.\n\n## Set\n\nA collection of `Rows` within a document.\n\n### Set#asArray()\n\nget the contents of this set as a regular js `Array`\n\n### Set#toJSON()\n\ncalls `toJSON` on the each `Row` in the set and puts it in an array.\n\n### Set#has(row|id)\n\ncheck if a row|id is a member of the set.\n\n### Set#get(id)\n\nget an item in this set, if it exists.\n\n### Set#each(iter), Set#forEach(iter)\n\nIterate over the `Rows` in the set.\n\n### Set#onEach(iter)\n\nIterate over the `Rows` in the set and any new row that may be\nadded to the set in the future.\n\n### Set#remove(row)\n\nremoves a row from the set. sets the set's `key`, to null.\nnote, if you have multiple sets with the same key, they are mutually exclusive,\nand adding a node to a different set will remove it from the first one.\n\n### event: Set.emit('add', Row)\n\nEmitted when a row is added to the set.\n\n### event: Set.emit('changes', Row, changed)\n\nEmitted when a row in the set changed. The changed value contains a hash\nof the key / values that changed.\n\n### event: Set.emit('remove', Row)\n\nEmitted when a row is removed from the set\n\n## Seq\n\njust like a Set, but the items are ordered.\nthey will begiven a `_sort` property.\n\n### Seq#first()\n\nget the first item in the seq.\n\n### Seq#last()\n\nget the last item in the seq.\n\n### Seq#has(row|id)\n\ncheck if a row|id is a member of the seq. (inherited from `Set`)\n\n### Seq#indexOf(id | row)\n\nfind the index of the given row or id.\n\n### Seq#at(index)\n\nget the item currently at `index`\n\n### Seq#unshift(row)\n\npush a `Row` onto the start of the `Seq`\n\n### Seq#push(row)\n\npush a `Row` onto the end of the `Seq`\n\n### Seq#length()\n\nget the number of items currently in the `Seq`.\n\n### Seq#pop()\n\nremove the last item.\n\n### Seq#shift()\n\nremove the first item.\n\n### Seq#before(item, id | row)\n\ninsert `item` before the given `row/id`.\n\n### Seq#after(item, id | row)\n\ninsert `item` after the given `row/id`.\n\n### Seq#next(key)\n\nFinds the item that is after this key\n\n### Seq#prev(key)\n\nFinds the item that is before this key\n\n### event: Seq.emit('move', Row)\n\nEmitted when the row has changed it's position in the sequence\n",
  "readmeFilename": "README.md",
  "_id": "crdt@3.5.1",
  "dist": {
    "shasum": "6404ba00f5798693975fc111ac4f1786747da89d"
  },
  "_from": "crdt@*",
  "_resolved": "https://registry.npmjs.org/crdt/-/crdt-3.5.1.tgz"
}
